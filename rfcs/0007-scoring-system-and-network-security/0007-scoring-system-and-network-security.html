<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>RFC0007 P2P Scoring System And Network Security - The Nervos RFC Book</title>
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="../../favicon.svg">
                        <link rel="shortcut icon" href="../../favicon.png">
                <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
                <link rel="stylesheet" href="../../css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="../../fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
                <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../../introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="../../rfcs/0001-positioning/0001-positioning.html">RFC0001 The Nervos Network Positioning Paper</a></li><li class="chapter-item expanded "><a href="../../rfcs/0002-ckb/0002-ckb.html">RFC0002 Nervos CKB: A Common Knowledge Base for Crypto-Economy</a></li><li class="chapter-item expanded "><a href="../../rfcs/0003-ckb-vm/0003-ckb-vm.html">RFC0003 CKB-VM</a></li><li class="chapter-item expanded "><a href="../../rfcs/0004-ckb-block-sync/0004-ckb-block-sync.html">RFC0004 CKB Block Synchronization Protocol</a></li><li class="chapter-item expanded "><a href="../../rfcs/0005-priviledged-mode/0005-priviledged-mode.html">RFC0005 Privileged architecture support for CKB VM</a></li><li class="chapter-item expanded "><a href="../../rfcs/0006-merkle-tree/0006-merkle-tree.html">RFC0006 Merkle Tree for Static Data</a></li><li class="chapter-item expanded "><a href="../../rfcs/0007-scoring-system-and-network-security/0007-scoring-system-and-network-security.html" class="active">RFC0007 P2P Scoring System And Network Security</a></li><li class="chapter-item expanded "><a href="../../rfcs/0008-serialization/0008-serialization.html">RFC0008 Serialization</a></li><li class="chapter-item expanded "><a href="../../rfcs/0009-vm-syscalls/0009-vm-syscalls.html">RFC0009 VM Syscalls</a></li><li class="chapter-item expanded "><a href="../../rfcs/0010-eaglesong/0010-eaglesong.html">RFC0010 Eaglesong (Proof-of-Work Function for Nervos CKB)</a></li><li class="chapter-item expanded "><a href="../../rfcs/0011-transaction-filter-protocol/0011-transaction-filter-protocol.html">RFC0011 Transaction Filter Protocol</a></li><li class="chapter-item expanded "><a href="../../rfcs/0012-node-discovery/0012-node-discovery.html">RFC0012 CKB Node Discovery Protocol</a></li><li class="chapter-item expanded "><a href="../../rfcs/0013-get-block-template/0013-get-block-template.html">RFC0013 get_block_template</a></li><li class="chapter-item expanded "><a href="../../rfcs/0014-vm-cycle-limits/0014-vm-cycle-limits.html">RFC0014 VM Cycle Limits</a></li><li class="chapter-item expanded "><a href="../../rfcs/0015-ckb-cryptoeconomics/0015-ckb-cryptoeconomics.html">RFC0015 Crypto-Economics of the Nervos Common Knowledge Base</a></li><li class="chapter-item expanded "><a href="../../rfcs/0017-tx-valid-since/0017-tx-valid-since.html">RFC0017 Transaction valid since</a></li><li class="chapter-item expanded "><a href="../../rfcs/0019-data-structures/0019-data-structures.html">RFC0019 Data Structures of Nervos CKB</a></li><li class="chapter-item expanded "><a href="../../rfcs/0020-ckb-consensus-protocol/0020-ckb-consensus-protocol.html">RFC0020 CKB Consensus Protocol</a></li><li class="chapter-item expanded "><a href="../../rfcs/0021-ckb-address-format/0021-ckb-address-format.html">RFC0021 CKB Address Format</a></li><li class="chapter-item expanded "><a href="../../rfcs/0022-transaction-structure/0022-transaction-structure.html">RFC0022 CKB Transaction Structure</a></li><li class="chapter-item expanded "><a href="../../rfcs/0023-dao-deposit-withdraw/0023-dao-deposit-withdraw.html">RFC0023 Deposit and Withdraw in Nervos DAO</a></li><li class="chapter-item expanded "><a href="../../rfcs/0024-ckb-system-script-list/0024-ckb-system-script-list.html">RFC0024 CKB System Script List</a></li><li class="chapter-item expanded "><a href="../../rfcs/0025-simple-udt/0025-simple-udt.html">RFC0025 Simple UDT</a></li><li class="chapter-item expanded "><a href="../../rfcs/0026-anyone-can-pay/0026-anyone-can-pay.html">RFC0026 Anyone-Can-Pay Lock</a></li><li class="chapter-item expanded "><a href="../../rfcs/0027-block-structure/0027-block-structure.html">RFC0027 CKB Block Structure</a></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">The Nervos RFC Book</h1>

                    <div class="right-buttons">
                                                <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        <a href="https://github.com/nervosnetwork/rfcs" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                                                                        <a href="https://github.com/nervosnetwork/rfcs/edit/master/rfcs/0007-scoring-system-and-network-security/0007-scoring-system-and-network-security.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>
                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <pre><code class="language-yaml">Number: &quot;0007&quot;
Category: Standards Track
Status: Proposal
Author: Jinyang Jiang
Organization: Nervos Foundation
Created: 2018-10-02
</code></pre>
<h1 id="p2p-scoring-system-and-network-security"><a class="header" href="#p2p-scoring-system-and-network-security">P2P Scoring System And Network Security</a></h1>
<h2 id="abstract"><a class="header" href="#abstract">Abstract</a></h2>
<p>This document describes the scoring system of CKB P2P Networking layer and several networking security strategies based on it.</p>
<h2 id="motivation"><a class="header" href="#motivation">Motivation</a></h2>
<p>CKB network is designed as an open peer-to-peer network and any node can join the network without permission. This openness, however, also makes it possible for malicious nodes to join and attack the peer-to-peer network.</p>
<p>There were &quot;Eclipse Attack&quot; security issues in both Bitcoin network and Ethereum network, which also designed as the open peer-to-peer network.
The principle of Eclipse Attack is that the attacker would occupy all Peers connection slots of the victim node by manipulating malicious nodes, then filter the victim's view of the blockchain network.</p>
<p>Via &quot;Eclipse Attack&quot; the attacker can take down a victim node with low cost. After that, the attacker could control the victim's mining power for its nefarious purposes, or cheat this victim node to launch a double spent attack.</p>
<p>Reference paper -- <a href="https://eprint.iacr.org/2015/263.pdf">Eclipse Attacks on Bitcoin’s Peer-to-Peer Network</a> </p>
<p>There are several strategies to prevent &quot;Eclipse attack&quot; introduced in this paper and parts of them have already been implemented in the Bitcoin network. That is to say, this document will describe how to deploy these strategies to CKB network.</p>
<p>In addition, this document also describes the scoring system of CKB P2P Networking layer and we want to handle more generalized network security cases by combining it with more sophisticated security strategies from the Bitcoin network.</p>
<p>Based on the scoring system, we can follow several rules below to handle malicious peers:</p>
<ol>
<li>Nodes should store peers information as much as possible.</li>
<li>Nodes need to score Peers' good and bad behavior continuously.</li>
<li>Nodes should retain good (high-score) peers and evict bad (low-score) peers out.</li>
</ol>
<p>CKB client should implement the scoring system and following security strategies.</p>
<h2 id="specification"><a class="header" href="#specification">Specification</a></h2>
<h3 id="terminology"><a class="header" href="#terminology">Terminology</a></h3>
<ul>
<li><code>Node</code></li>
<li><code>Peer</code> - Other nodes connected through the network</li>
<li><code>PeerInfo</code> - A data struct used for describing information of <code>Peer</code></li>
<li><code>PeerStore</code> - A component used to store <code>PeerInfo</code></li>
<li><code>outbound peer</code> - describe a peer which initiates a connection.</li>
<li><code>inbound peer</code> - describe a peer which accepts a connection.</li>
<li><code>max_outbound</code> - Max number of outbound peers.</li>
<li><code>max_inbound</code> - Max number of inbound peers.</li>
<li><code>network group</code> - A concept which used when to evict out peers, calculating from the peer's IP address(prefix 16 bits of IPv4 and prefix 32 bits of IPv6).</li>
</ul>
<h3 id="peer-store-and-peer-info"><a class="header" href="#peer-store-and-peer-info">Peer Store and Peer Info</a></h3>
<p>PeerStore should be persistent storage and store PeerInfos as more as possible.</p>
<p>PeerInfo should include fields below at least:</p>
<pre><code>PeerInfo { 
  NodeId,
  ConnectedIP,
  Direction,  // Inbound or Outbound
  LastConnectedAt, // The time of the last connection 
  Score
}
</code></pre>
<h3 id="scoring-system"><a class="header" href="#scoring-system">Scoring System</a></h3>
<p>Parameters below are required in Scoring System:</p>
<ul>
<li><code>PEER_INIT_SCORE</code> - the initial score of peers</li>
<li><code>BEHAVIOURS</code> - a set of peer's possible behaviors, such as: <code>UNEXPECTED_DISCONNECT</code>, <code>TIMEOUT</code>, <code>CONNECTED</code></li>
<li><code>SCORING_SCHEMA</code> - describe different scores corresponding to different behaviors, such as: <code>{&quot;TIMEOUT&quot;: -10, &quot;CONNECTED&quot;: 10}</code></li>
<li><code>BAN_SCORE</code> - a peer will be banned when its score is lower than this value.</li>
</ul>
<p>Network layer should provide the scoring interface, allow upper sub-protocols (such as: <code>sync</code>, <code>relay</code>) to report behaviors of a peer, and update peer's score based on <code>SCORING_SCHEMA</code>.</p>
<pre><code class="language-ruby">peer.score += SCOREING_SCHEMA[BEHAVIOUR]
</code></pre>
<p>Peer's behaviors can be distinguished into three categories:</p>
<ol>
<li>Correct behaviors which follow the specification:
<ul>
<li>For example, a node downloads a new block from a peer; a node connects to a peer successfully. Considering a bad peer may pretend like a good one before launching an attack, we should give the peer a relatively low positive score instead of giving a high score at once to encourage the peer to accumulate his credit by performing good behaviors for a long time.</li>
</ul>
</li>
<li>Incorrect behaviors which may be caused by network exception:
<ul>
<li>For example, a peer disconnect unexpectedly; a node failed to connect to a peer; ping timeout. Since we can't tell whether these behaviors are intentional bad behavior or caused by the network,  we should give the peer a little negative score to keep tolerant.</li>
</ul>
</li>
<li>Incorrect behaviors which violate the protocol:
<ul>
<li>For example, a peer sends an illegal encoded content; a peer sends an invalid block; a peer sends an invalid transaction. We should give a peer a negative score when we can be pretty sure its behavior is malicious, and when a peer's score is lower than <code>BAN_SCORE</code>, this peer should be banned.</li>
</ul>
</li>
</ol>
<p>Examples:</p>
<ul>
<li>Peer 1 connected successfully. A node reported this peer's <code>CONNECTED</code> behavior and peer 1 got a 10 score rewarded.</li>
<li>Peer 2 gets a connection timeout. A node reports <code>TIMEOUT</code> behavior and peer 2 get a -10 score as punishment.</li>
<li>Peer 1 sent repetitive <code>GET_BLOCK</code> messages. A node reported <code>DUPLICATED_REQUEST_BLOCK</code> behavior and peer 1 got a -50 score as punishment.</li>
<li>Peer 1's score is lower than <code>BAN_SCORE</code>, node disconnect with peer 1 then ban the peer.</li>
</ul>
<p>Parameters like <code>BEHAVIOURS</code>, <code>SCORING_SCHEMA</code> are not a part of consensus protocol, so CKB client should tune these parameters according to the actual situation of the network.</p>
<h3 id="outbound-peers-selection"><a class="header" href="#outbound-peers-selection">Outbound peers selection</a></h3>
<p>The &quot;Eclipse Attack&quot; paper describes a critical security issue during Bitcoin node restarting process:</p>
<ol>
<li>The attacker tries to fit the victim node's addrman(Bitcoin's peer store) with attacker's bad nodes' addresses.</li>
<li>The attacker waits the victim node to restart (or use several methods to force it).</li>
<li>After the restart, the victim node will select some address from addrman to connect.</li>
<li>The attack successes if all outbound connections of the victim node are connected to the attacker's bad nodes.</li>
</ol>
<p>CKB should avoid this problem when initialize the network.</p>
<h4 id="the-process-of-initializing-outbound-peers"><a class="header" href="#the-process-of-initializing-outbound-peers">The process of initializing outbound peers</a></h4>
<p>Required parameters:</p>
<ul>
<li><code>TRY_SCORE</code> - We only try to connect a peer when its score is higher than this value.</li>
<li><code>ANCHOR_PEERS</code> - the number of anchor peers should be less than <code>max_outbound</code>, such as <code>2</code></li>
</ul>
<p>Required variables:</p>
<ul>
<li><code>try_new_outbound_peer</code> - network component checks this variable to decide whether to connect to extra outbound peers or not.</li>
</ul>
<p>The process of choosing an outbound peer:</p>
<ol>
<li>Execute step 2 if currently connected outbound peers less than <code>ANCHOR_PEERS</code>, otherwise execute step 3.</li>
<li>Choose an &quot;anchor peer&quot;:
<ol>
<li>Choose recently connected outbound peers from peer store(can select by <code>LastConnectedAt</code> field of peer info).</li>
<li>Execute step 3, if <code>recent_peers</code> is empty; otherwise, we choose the peer which has got the highest score from <code>recent_peers</code> and return it as the new outbound peer.</li>
</ol>
</li>
<li>Choose peer info randomly which must have a higher score than <code>TRY_SCORE</code> and have different <code>network group</code> from all currently connected outbound peers from PeerStore, return it as the new outbound peer and if we can't find anyone, then execute step 4.</li>
<li>Choose peer info randomly from boot nodes.</li>
</ol>
<p>In step 1, we choose an anchor peer if the node has zero or only a few connected outbound peers. This behavior refers to &quot;Anchor Connection&quot; strategy which described in the <a href="https://eprint.iacr.org/2015/263.pdf">Eclipse Attack</a> paper.</p>
<p>Pseudocode:</p>
<pre><code class="language-ruby"># return our new outbound peer
def find_outbound_peer
  connected_outbound_peers = connected_peers.select{|peer| peer.outbound? &amp;&amp; !peer.feeler? }
  # step 1
  if connected_outbound_peers.length &lt; ANCHOR_PEERS
    find_anchor_peer() || find_random_peer() || random_boot_node()
  else
    find_random_peer() || random_boot_node()
  end
end

# step 2
def find_anchor_peer
  last_connected_peers = peer_store.sort_by{|peer| -peer.last_connected_at}.take(max_outbound)
  # return the higest scored peer info
  last_connected_peers.sort_by(&amp;:score).last
end

# step 3
def find_random_peer
  connected_outbound_peers = connected_peers.select{|peer| peer.outbound? &amp;&amp; !peer.feeler? }
  exists_network_groups = connected_outbound_peers.map(&amp;:network_group)
  candidate_peers = peer_store.select do |peer| 
    peer.score &gt;= TRY_SCORE &amp;&amp; !exists_network_groups.include?(peer.network_group)
  end
  candidate_peers.sample
end

# step 4
def random_boot_node
  boot_nodes.sample
end
</code></pre>
<p>The node should repeat this process until the number of connected outbound peers is equal to or greater than  <code>max_outbound</code> and <code>try_new_outbound_peer</code> is <code>false</code>.</p>
<pre><code class="language-ruby">check_outbound_peers_interval = 15
# continually check the number of outbound peers
loop do
  sleep(check_outbound_peers_interval)
  connected_outbound_peers = connected_peers.select{|peer| peer.outbound? &amp;&amp; !peer.feeler? }
  if connected_outbound_peers.length &gt;= max_outbound &amp;&amp; !try_new_outbound_peer 
    next
  end
  new_outbound_peer = find_outbound_peer()
  connect_peer(new_outbound_peer)
end
</code></pre>
<p><code>try_new_outbound_peer</code> variable is used for some situation where a node can't get any useful messages in a duration time. Then we will set <code>try_new_outbound_peer</code> to <code>true</code> and allow the node to connect to more extra outbound peers. This strategy would be introduced later.</p>
<p>Under this strategy, the attacker must achieve the following conditions to apply an eclipse attack:</p>
<ol>
<li>The attacker needs to have <code>n</code> malicious peers (<code>n == ANCHOR_PEERS</code>) to be the victim node's outbound peers and these peers must have the highest scores.</li>
<li>The attacker needs to prepare at least <code>max_outbound - ANCHOR_PEERS</code> bad peers' addresses in PeerStore. At the same time, the attacker must make sure that the randomly selected <code>max_outbound - ANCHOR_PEERS</code> outbound peers are all camouflage nodes of the attacker.</li>
</ol>
<h4 id="extra-outbound-peers-and-eviction"><a class="header" href="#extra-outbound-peers-and-eviction">Extra outbound peers and eviction</a></h4>
<p>Network component should check the main protocol (for example: <code>sync</code> protocol in CKB) status every few minutes.</p>
<pre><code class="language-ruby">def sync_maybe_stale
  now = Time.now
  # use block product time to detect network status
  # we consider network maybe stale if block not produced within a predicted time
  last_tip_updated_at &lt; now - block_produce_interval * n
end
</code></pre>
<p>The network component should set <code>try_new_outbound_peer</code> to <code>true</code> when <code>sync</code> protocol doesn't work and set back to <code>false</code> when <code>sync</code> protocol puts back.</p>
<pre><code class="language-ruby">check_sync_stale_at = Time.now
loop_interval = 30
check_sync_stale_interval = 15 * 60 # 15 minutes

loop do
  sleep(loop_interval)
  # try evict
  evict_extra_outbound_peers()
  now = Time.now
  if check_sync_stale_at &gt;= now
    # update try_new_outbound_peer
    set_try_new_outbound_peer(sync_maybe_stale())
    check_sync_stale_at = now + check_sync_stale_interval
  end
end
</code></pre>
<p>CKB network will try to connect to extra outbound peers continually when <code>try_new_outbound_peer</code> is <code>true</code>, and try to evict useless extra peers every few minutes to prevent too many connections.</p>
<pre><code class="language-ruby"># eviction logic
def evict_extra_outbound_peers
  connected_outbound_peers = connected_peers.select{|peer| peer.outbound? &amp;&amp; !peer.feeler? }
  if connected_outbound_peers.length &lt;= max_outbound
    return
  end
  now = Time.now
  # here use last_block_anoncement_at to evict peers, we assume the oldest one is useless for us
  evict_target = connected_outbound_peers.sort_by do |peer|
    peer.last_block_announcement_at
  end.first
  if evict_target
    if now - evict_target.last_connected_at &gt; MINIMUM_CONNECT_TIME &amp;&amp; !is_downloading?(evict_target)
      disconnect_peer(evict_target)
      # prevent connect to too many peers
      set_try_new_outbound_peer(false)
    end
  end
end
</code></pre>
<h3 id="the-process-of-accepting-inbound-peers"><a class="header" href="#the-process-of-accepting-inbound-peers">The process of accepting inbound peers</a></h3>
<p>In Bitcoin, a node will try to evict connected inbound peers if the number of connected inbound peers reaches <code>max_inbound</code> and another new inbound connection tries to connect. (check <a href="https://github.com/bitcoin/bitcoin">Bitcoin source code</a> for details)</p>
<p>This eviction behavior is intended to keep high-quality peers and evict low-quality peers.</p>
<p>CKB refers to Bitcoin's eviction test and steps are as follows:</p>
<ol>
<li>Consider currently connected inbound peers as <code>candidate_peers</code>.</li>
<li>Protect peers(<code>N</code> represent the number of peers to protect in each step):
<ol>
<li>Delete <code>N</code> peers from <code>candidate_peers</code> which has the highest score.</li>
<li>Delete <code>N</code> peers from <code>candidate_peers</code> which has the lowest ping.</li>
<li>Delete <code>N</code> peers from <code>candidate_peers</code> which most recently sent us messages.</li>
<li>Delete <code>candidate_peers.size / 2</code> peers from <code>candidate_peers</code> which have the longest connection time.</li>
</ol>
</li>
<li>Group <code>candidate_peers</code> according to <code>network group</code> field.</li>
<li>Find out the group which contains the most peers.</li>
<li>Evict the lowest scored peer from the group found in step 4 if it is not empty. Otherwise, reject the connection from the new peer.</li>
</ol>
<p>We protect some peers from eviction based on characteristics that an attacker is hard to simulate or manipulate, to enhence the security of the network.</p>
<h3 id="feeler-connection"><a class="header" href="#feeler-connection">Feeler Connection</a></h3>
<p>Feeler Connection is intended to test a peer is connectable or not.</p>
<p>Node will start a feeler connection every few minutes after outbound peers reach <code>max_outbound</code> limit.</p>
<ol>
<li>Pick out peer info from PeerStore randomly which we never connected to</li>
<li>Connect to this peer</li>
<li>Run handshake protocol</li>
<li>Disconnect</li>
</ol>
<p>Feeler peers would be assumed to disconnect soon.</p>
<h3 id="delete-peer-info-from-peerstore"><a class="header" href="#delete-peer-info-from-peerstore">Delete peer info from PeerStore</a></h3>
<p>Required parameters:</p>
<ul>
<li><code>PEER_STORE_LIMIT</code> - max number of PeerInfo in PeerStore</li>
<li><code>PEER_NOT_SEEN_TIMEOUT</code> - used for protecting peers which recently connected. Only peer info over <code>last_connected_to</code> would be deleted. </li>
</ul>
<p>When the number of peer info reaches <code>PEER_STORE_LIMIT</code>:</p>
<ol>
<li>Group all PeerInfos in PeerStore according to <code>network group</code> field</li>
<li>Find out the group which contains the most peer infos</li>
<li>Search peers have not been connected recently from this group: <code>peer.last_connected_at &lt; Time.now - PEER_NOT_SEEN_TIMEOUT</code></li>
<li>Find out the lowest scored peer info as <code>candidate_peer_info</code></li>
<li>if <code>candidate_peer_info.score &lt; new_peer_info.score</code> then we delete <code>candidate_peer_info</code> and add <code>new_peer_info</code>, otherwise we do not accept <code>new_peer_info</code></li>
</ol>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<ol>
<li><a href="https://github.com/bitcoin/bitcoin">Bitcoin source code</a></li>
<li><a href="https://eprint.iacr.org/2015/263.pdf">Eclipse Attacks on Bitcoin’s Peer-to-Peer Network</a></li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                                                    <a rel="prev" href="../../rfcs/0006-merkle-tree/0006-merkle-tree.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        
                                                    <a rel="next" href="../../rfcs/0008-serialization/0008-serialization.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                                    <a rel="prev" href="../../rfcs/0006-merkle-tree/0006-merkle-tree.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                
                                    <a rel="next" href="../../rfcs/0008-serialization/0008-serialization.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        
    </body>
</html>
